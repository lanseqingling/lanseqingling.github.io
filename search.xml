<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>记一次慢SQL引发的头脑风暴</title>
      <link href="/2025/06/21/3-SQL/"/>
      <url>/2025/06/21/3-SQL/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在一个阳光明媚的早晨，报警机器人邀我共进早餐：MySQL 集群 CPU 高涨，达到 70% 并持续了数十秒，我查看监控和日志，定位异常来源于下面这条 SQL ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> XXX</span><br><span class="line"><span class="keyword">WHERE</span> tenant_id <span class="operator">=</span> ?</span><br><span class="line"><span class="keyword">AND</span> space_type <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">AND</span> space_version <span class="operator">=</span> ?</span><br><span class="line"><span class="keyword">AND</span> (delete_flag <span class="operator">=</span> <span class="number">0</span> <span class="keyword">OR</span> delete_flag <span class="operator">=</span> <span class="number">255</span>) </span><br><span class="line"><span class="keyword">AND</span> default_attr <span class="operator">!=</span> ? </span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Method</span><span class="params">(ctx context.Context, tenantId <span class="type">int64</span>, excludeSpaceType []SpaceType)</span></span> (<span class="type">int64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> count <span class="type">int64</span></span><br><span class="line">    err := db(ctx).Table(XXX).</span><br><span class="line">    Where(<span class="string">&quot;tenant_id = ? and space_version = ? and (delete_flag = ? or delete_flag = ?) and default_attr != ? and space_type not in (?)&quot;</span>, tenantId, ..., excludeSpaceType).</span><br><span class="line">    Count(&amp;count).Error</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>目标 SQL 是一个多条件的 COUNT 查询，先来看看可用索引情况：</p><ul><li>索引A：<code>KEY idx_tid_spaceid (tenant_id, space_id)</code></li><li>索引B：<code>KEY idx_tid_scope_ctime (tenant_id, scope, create_time)</code></li><li>索引C：<code>KEY idx_tid_stype_scope_sid (tenant_id, space_type, scope, space_id)</code></li></ul><table><thead><tr><th align="left">字段</th><th align="left">条件</th><th align="left">索引情况</th><th align="left">是否利用索引</th></tr></thead><tbody><tr><td align="left">tenant_id</td><td align="left">&#x3D;</td><td align="left">索引A、索引B、索引C</td><td align="left">是</td></tr><tr><td align="left">space_type</td><td align="left">NOT IN</td><td align="left">索引C</td><td align="left">否</td></tr><tr><td align="left">space_version</td><td align="left">&#x3D;</td><td align="left">-</td><td align="left">否</td></tr><tr><td align="left">delete_flag</td><td align="left">&#x3D;、OR</td><td align="left">-</td><td align="left">否</td></tr><tr><td align="left">default_attr</td><td align="left">!&#x3D;</td><td align="left">-</td><td align="left">否</td></tr></tbody></table><p>同时存在 <code>!=</code>、<code>or</code>、<code>not in</code> 条件，简直反索引拉满，索引利用率极低，查询大租户时内存筛选耗时巨大，因此执行超时，Explain 查看执行计划也证实了这一点：</p><table><thead><tr><th align="left">列名</th><th align="left">列值</th></tr></thead><tbody><tr><td align="left">key</td><td align="left">idx_tid_spaceid</td></tr><tr><td align="left">rows</td><td align="left">?</td></tr><tr><td align="left">filtered</td><td align="left">1.2</td></tr><tr><td align="left">Extra</td><td align="left">Using where</td></tr></tbody></table><h1 id="初见端倪"><a href="#初见端倪" class="headerlink" title="初见端倪"></a>初见端倪</h1><p>SQL优化的手段很多，我们先来看看能否提高索引覆盖率。可以发现索引C的覆盖条件中的字段是最多的 (tenant_id, space_type, scope, space_id) 。其中 space_type 由于使用了反范围查询的 <code>NOT IN</code> ，无法利用索引。通过分析代码可知 space_type 只有4种枚举类型，且传值固定，可以替换成等效的等值查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 原条件：</span></span><br><span class="line">space_type <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">-- 替换为：</span></span><br><span class="line">space_type <span class="operator">=</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>这样一来，我们就使用到了索引的前个字段，但由于 space_type 的筛选度不高，扫描后内存筛选的压力还是很大，依然存在慢查询风险。</p><p><img src="/2025/06/21/3-SQL/1.png" alt="1"></p><p>那么，我们是否可以把数据返回给应用层进行筛选呢？按照刚刚优化的索引情况，通过一次回表查询所有数据到内存：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> space_version, delete_flag, default_attr <span class="keyword">FROM</span> ？</span><br><span class="line"><span class="keyword">WHERE</span> tenant_id <span class="operator">=</span> ?</span><br><span class="line"><span class="keyword">AND</span> space_type <span class="operator">=</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>但当数据量非常大时，这样的SQL是能否解决慢查询不说，不仅网络传送压力大，可能还存在堆内存溢出的风险。基于此可以很容易想到，通过在应用层维护一个的游标，对数据进行分批查询，手动筛选计数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> space_id,space_version, delete_flag, default_attr <span class="keyword">FROM</span> ？</span><br><span class="line"><span class="keyword">WHERE</span> tenant_id <span class="operator">=</span> ?</span><br><span class="line"><span class="keyword">AND</span> space_type <span class="operator">=</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">AND</span> space_id <span class="operator">&gt;</span> ?</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> space_id</span><br><span class="line">LIMIT <span class="number">1000</span></span><br></pre></td></tr></table></figure><h1 id="面露难色"><a href="#面露难色" class="headerlink" title="面露难色"></a>面露难色</h1><p>可这条 SQL 怎么越看越不对劲，当我再次执行 Explain ，顿时令我黯然失色，SQL 改用了索引 <code>uniq_space_id</code> 。</p><table><thead><tr><th align="left">列名</th><th align="left">列值</th></tr></thead><tbody><tr><td align="left">key</td><td align="left">uniq_space_id</td></tr><tr><td align="left">rows</td><td align="left">?</td></tr><tr><td align="left">filtered</td><td align="left">3.36</td></tr><tr><td align="left">Extra</td><td align="left">Using index condition; Using where</td></tr></tbody></table><p>简单分析可以发现，且为了保证 space_id 的顺序性，需要使用 <code>ORDER BY</code>  ，这种情况下优化器为了避免排序，认为直接使用 space_id 的唯一索引利用索引的顺序性效率更高。但这也导致了扫描数据量的进一步增加，虽然不会导致单条 SQL 超时，但效率依旧低下。</p><p>正当我一筹莫展的时候，我注意到索引 <code>idx_tid_stype_scope_sid</code> 最后一个列恰好是 space_id ，但由跳过了 scope 条件，不符合索引原则，还是无法利用索引：</p><p><img src="/2025/06/21/3-SQL/2.png" alt="2"></p><h1 id="曙光初现"><a href="#曙光初现" class="headerlink" title="曙光初现"></a>曙光初现</h1><p>难道就没有更好的办法了吗？在查看了 scope 的枚举后，发现枚举的值并不多，且不会随意扩展，那是不是意味着可以手动补齐 scope 字段，不仅完全利用到了索引，还可以并发执行多条SQL，在确认了不会有事务风险后，最终的 SQL 变成了下面这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> space_id,space_version, delete_flag, default_attr <span class="keyword">FROM</span> ？</span><br><span class="line"><span class="keyword">WHERE</span> tenant_id <span class="operator">=</span> ?</span><br><span class="line"><span class="keyword">AND</span> space_type <span class="operator">=</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">AND</span> <span class="keyword">scope</span> <span class="operator">=</span> ?</span><br><span class="line"><span class="keyword">AND</span> space_id <span class="operator">&gt;</span> ?</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> space_id</span><br><span class="line">LIMIT <span class="number">1000</span></span><br></pre></td></tr></table></figure><p><img src="/2025/06/21/3-SQL/3.png" alt="3"></p><p>下面是优化后的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Method</span><span class="params">(ctx context.Context, tenantId <span class="type">int64</span>)</span></span> (<span class="type">int64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> limit <span class="type">int64</span> = <span class="number">1000</span></span><br><span class="line">    <span class="keyword">var</span> count <span class="type">int64</span></span><br><span class="line">    scopes := []Scope&#123;</span><br><span class="line">        <span class="comment">// 枚举...</span></span><br><span class="line">    &#125;</span><br><span class="line">    executor := concurrent.WithContext(ctx)</span><br><span class="line">    <span class="keyword">for</span> _, s := <span class="keyword">range</span> scopes &#123;</span><br><span class="line">       scope := s</span><br><span class="line">       <span class="comment">// 并发执行</span></span><br><span class="line">       executor.Go(<span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> start <span class="type">int64</span></span><br><span class="line">          <span class="keyword">var</span> cnt <span class="type">int64</span></span><br><span class="line">          <span class="keyword">for</span> &#123;</span><br><span class="line">             <span class="keyword">var</span> result []*Result</span><br><span class="line">             err := db(ctx).Table(XXX).</span><br><span class="line">                Select(<span class="string">&quot;space_id, space_version, delete_flag, default_attr&quot;</span>).</span><br><span class="line">                Where(<span class="string">&quot;tenant_id=? and space_type=? and scope=?&quot;</span>, tenantId, <span class="number">4</span>, scope).</span><br><span class="line">                Where(<span class="string">&quot;space_id &gt; ?&quot;</span>, start).</span><br><span class="line">                Order(<span class="string">&quot;space_id&quot;</span>).</span><br><span class="line">                Limit(limit).</span><br><span class="line">                Find(&amp;result).Error</span><br><span class="line">             <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">for</span> _, res := <span class="keyword">range</span> result &#123;</span><br><span class="line">                <span class="comment">// 手动过滤......</span></span><br><span class="line">                cnt++</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> <span class="built_in">len</span>(result) &lt; <span class="type">int</span>(limit) &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">             &#125;</span><br><span class="line">             start = result[<span class="built_in">len</span>(result)<span class="number">-1</span>].SpaceId</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 手动计数</span></span><br><span class="line">          atomic.AddInt64(&amp;count, cnt)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">       &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := executor.Wait(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果担心优化器乱搞事情，还可以强制指定索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use index (idx_tid_stype_scope_sid)</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这次的问题 SQL 其实非常简单，但又非常经典，整个优化分析过程涉及了很多索引知识。慢 SQL 的优化的方式很多，不过大多数都可以总结为：减少查询数据量、提升索引命中率、减少磁盘 I\O 次数。除了 SQL 本身都优化，本次也利用了应用层分担数据库压力，通过手动筛选计数，并发分页扫描有效平衡了性能和内存使用率。</p><p>分享本次案例对我们有何启发呢？我们无法预测系统数据量的爆炸增长，以至于现在看起来没毛病的 SQL ，在未来可能成为隐患。我们可以为了保证效率不要求每个细节追求极致，但还是需要尽可能遵守设计原则，让系统尽可能保持稳定运行。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap原理与细节</title>
      <link href="/2024/02/22/2-HashMap/"/>
      <url>/2024/02/22/2-HashMap/</url>
      
        <content type="html"><![CDATA[<h1 id="HashMap概述"><a href="#HashMap概述" class="headerlink" title="HashMap概述"></a>HashMap概述</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Java为数据结构的映射定义了一个接口<code>java.util.Map</code>，其中有四个常用实现类：HashMap、HashTable、LinkedHashMap和TreeMap。</p><p><img src="/2024/02/22/2-HashMap/Map.svg" alt="Map"></p><p><strong>HashMap</strong>：根据键的<code>hashCode</code>值存储数据，允许一条记录的键为null，访问速度快，遍历顺序不稳定。HashMap线程不安全，并发环境可以使用Collections的syncronizedMap方法将它包装为线程安全的Map但是更推荐使用ConcurrentHashMap。<code>JDK8</code>以前HashMap使用数组＋链表的数据结构，而<code>JDK8</code>之后引入了红黑树结构，查找时间复杂度为O(logn)，当链表长度大于8并且数组长度大于64时会将链表转为红黑树。</p><p><strong>LinkedHashMap</strong>：LinkedHashMap是HashMap的一个子类，通过加入双向链表保证了遍历的有序性。</p><p><strong>Hashtable</strong>：Hashtable功xd能与HashMap类似，不同点是它继承<code>Dictionary</code>类，因此键值都不允许null，它直接对方法添加<code>synchronized</code>，是线程安全的。</p><p><strong>TreeMap</strong>：TreeMap实现<code>SortedMap</code>接口，默认是按键值的升序排序，也可以指定排序的比较器，如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，它的key不能为null，key必须实现<code>Comparable</code>接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出<code>java.lang.ClassCastException</code>类型的异常。</p><h2 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h2><p><strong>哈希值（hashCode）</strong>：为了支持哈希表而定义在Object中通过<code>hashCode</code>方法获取的对象散列码，它是一个int类型的整数，默认情况下使用对象的存储地址。</p><p>在HashMap中，存储键值对的数组地址就是通过对hashCode进行哈希算法获得的，而当数组的这个地址上有元素时会调用key的<code>equals</code>方法判断键是否重复，如果键储存引用数据类型，需要同时重写<code>hashCode</code>和<code>equals</code>方法，以维护为了维护<code>equals</code>方法的一般约定：<code>equals</code>判断相等的对象<code>hashCode</code>也必须相等。</p><h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><p>当对两个不同存储元素进行哈希运算得到地址相同时，就发生了<strong>哈希冲突（哈希碰撞）</strong>，解决哈希冲突的方案有很多：开放寻址法、连地址法、再散列函数法等，而HashMap采用了链地址法来解决哈希冲突。</p><h1 id="HashMap详解"><a href="#HashMap详解" class="headerlink" title="HashMap详解"></a>HashMap详解</h1><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>HashMap存储结构基于数组＋链表+红黑树（JDK8新增）实现。</p><p>HashMap中的哈希桶数组采用<code>Node</code>数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><p><code>Node</code>类型实现类<code>Map.Entry</code>接口，定义为一个映射（键值对）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span>        &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span>      &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于扩容后的红黑树结构，则是使用TreeNode结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="type">boolean</span> red;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于链表的查找时间复杂度为<code>O(n)</code>，而红黑树结构的查找时间复杂度为<code>O(logn)</code>，当数据量较大时优于链表，因此引入了红黑树结构。</p><p>将链表长度阈值设置为8有几个原因：一是当链表长度达到8时，由于链表的平均查找长度位<code>n/2</code>等于4，此时红黑树平均查找长度为log2(8)等于3，之后红黑树查找效率才会开始显著高于链表；二是键值对分布满足泊松分布，大部分情况下在数组中分散较为均匀，当链表长度还未达到8时就已经扩容，HashMap维护的几乎都是链表，只有性能已经很差时才会达到树化阈值8。</p><h2 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h2><p>HashMap定义了几个重要的成员属性。</p><p>数组的默认初始容量为16，且扩容后必须为2的幂（合数）。常规设计是把桶的大小规定为素数，因为素数导致的冲突概率小于合数，因此Hashtable初始桶容量为11，而HashMap采用合数是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br></pre></td></tr></table></figure><p>荷载系数（加载因子），默认为0.75，当键值对数量size大于数组容量乘以荷载系数时数组会进行扩容。默认值定义为0.75是在时间和空间成本之间提供了良好的权衡。较高的值会减少空间开销，但会增加查找成本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure><p>链表的阈值长度默认为8，数组树化最小长度为64，即当数组长度大于64且链表长度大于8时链表结构转为红黑树结构，而取消树化的默认阈值为6。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br></pre></td></tr></table></figure><h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>计算哈希值是操作键值对的第一步，最终的哈希值是取hashCode的高位参与运算。值为null的键无法获取hashCode，因此直接返回0值，这也决定了HashMap只能存储一个值为null的键，而value不参与计算因此可以存在多个记录为null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而键对应的最终数组下标并非hash值，通常是将hash值对数组长度取模运算，这样得到的数组下标的分布较为均匀，但取模消耗较大，因此HashMap通过效率更高的<code>(n - 1) &amp; hash</code>运算得到保存位。由于数组长度总是2的幂，这种运算等价于对n取模，也就是hash%n。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tab[i = (n - <span class="number">1</span>) &amp; hash]</span><br></pre></td></tr></table></figure><p><code>JDK8</code>中优化了高位运算算法，是通过hashCode的高16位异或低16位实现的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> h = key.hashCode() : 1111 1111 1111 1111 1111 0000 1110 1010</span><br><span class="line">   h &gt;&gt;&gt; 16 : 0000 0000 0000 0000 1111 1111 1111 1111</span><br><span class="line">hash = h ^ h &gt;&gt;&gt; 16: 1111 1111 1111 1111 0000 1111 0001 0101</span><br><span class="line"></span><br><span class="line"> (n - 1) &amp; hash : 0000 0000 0000 0000 0000 0000 0000 1111</span><br><span class="line">  1111 1111 1111 1111 0000 1111 0001 0101 </span><br><span class="line">  i : 0101 = 5</span><br></pre></td></tr></table></figure><h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h2><p>HashMap调用无参构造时并不会创建Node数组，只有在第一次调用put方法时才会创建长度为16的数组，这个过程在数组扩容方法<code>resize</code>中完成。</p><p>HashMap调用put方法的大概流程为：</p><ol><li>判断数组<code>table</code>是否为空或为null，是则调用<code>resize</code>方法扩容，初始容量为16。</li><li>根据key的<code>hash</code>值计算数组下标<code>i</code>，如果<code>table[i]</code>为空则直接添加，如果不为空但调用首元素key值的<code>equals</code>方法判断键相同则覆盖并返回旧值，覆盖操作不会创建新的<code>Node</code>结点。</li><li>判断<code>table[i]</code>结点是否为<code>TreeNode</code>类型，如果是则安装红黑树规则添加元素。</li><li>若非红黑树则按照链表规则遍历，遍历过程中如果key存在则覆盖元素，否则插入链表尾部。此时如果链表长度大于<code>8</code>则调用<code>treeifyBin</code>方法将链表转为红黑树（方法内会判断键值对数量是否达到<code>64</code>，是则树化否则仅扩容）。</li><li>插入后判断键值对数量<code>size</code>是否大于<code>threshold</code>（数组容量乘以荷载系数），是则调用<code>resize</code>方法扩容。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// 数组为空则初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// table[i]为空直接添加</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 首元素key值相同直接覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 判断是否为红黑树，按照红黑树添加</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 插入成功后判断是否转为红黑树</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// key值相同则覆盖</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 覆盖并返回旧值，不会创建新的Node结点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否扩容</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h2><p>在<code>JDK7</code>中，会先引用扩容前的Entry数组，若数组大小已达到最大则不会再扩容，之后会创建一个新的Entry数组获取旧Entry的所有元素，释放旧Entry数组对象引用并重新计算每个元素在数组的位置，新的链表采用头插法创建链表。</p><p>而<code>JDK8</code>做了优化，由于使用2次幂扩容，重新计算hash值后只会修改高位bit，元素的位置要么在原位置上，要么移动2次幂的位置，因此不需要重新计算hash，只需要判断新增位bit的值，如果为0则索引不变，如果为1则新索引等于原索引+<code>oldCap</code>，重新得到的链表也不会倒置。</p><p>哈希运算后同一数组位置的key被分散到了原位置和原索引+oldCap位置上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">oldCap : .... 0000 1111</span><br><span class="line"> hash1 : .... 0000 0101 -&gt; .... 0000 0101 -&gt; 00101 = 5</span><br><span class="line"> hash2 : .... 1111 0101 -&gt; .... 0000 0101 -&gt; 00101 = 5</span><br><span class="line">   </span><br><span class="line">newCap : .... 0001 1111</span><br><span class="line"> hash1 : .... 0000 0101 -&gt; .... 0000 0101 -&gt; 00101 = 5</span><br><span class="line"> hash2 : .... 1111 0101 -&gt; .... 0001 0101 -&gt; 10101 = 5 + 16</span><br></pre></td></tr></table></figure><p>尽管如此，扩容仍极为消耗性能，因此使用HashMap时尽可能估算Map的大小，初始化一个大概的数值，避免频繁扩容。</p><h2 id="多线程死循环"><a href="#多线程死循环" class="headerlink" title="多线程死循环"></a>多线程死循环</h2><p>HashMap是线程不安全的，并发环境下会发生多种错误，严重时会导致链表循环引用进而导致死循环。</p><p>在<code>JDK7</code>中一个典型的例子是：当两个线程添加完元素同时执行到resize方法时，第一个线程在原数组中遍历链表的过程中，第二个线先完成了rehash链表重组，使得链表倒置，此时线程一结点便指向之前的结点导致了循环链表。</p><h2 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h2><p>HashMap有多种常用的遍历方式：遍历<code>keySet</code>集合、遍历<code>entrySet</code>集合、<code>Lambda</code>表达式直接遍历Map、获取<code>entrySet</code>的<code>iterator</code>迭代器进行遍历等，其中更推荐使用迭代器，效率较高，且能够直接调用迭代器的<code>remove</code>方法移除当前键值对。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://tech.meituan.com/2016/06/24/java-hashmap.html">https://tech.meituan.com/2016/06/24/java-hashmap.html</a></li><li><a href="https://cloud.tencent.com/developer/article/1830825">HashMap底层实现原理-腾讯云开发者社区-腾讯云 (tencent.com)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> HashMap </tag>
            
            <tag> Map </tag>
            
            <tag> 原理 </tag>
            
            <tag> 源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CompletableFuture详解】换一种理解角度 - 被忽略的函数式接口</title>
      <link href="/2024/02/05/1-CompletableFuture/"/>
      <url>/2024/02/05/1-CompletableFuture/</url>
      
        <content type="html"><![CDATA[<h1 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很多文章在介绍CompletableFuture时都是照功能将方法划分为不同类型，直接解释具体方法的使用规则。可如果你本就英语不好，看到几个差不多的单词排列组合成几十种方法是不是头皮发麻了？又或者你经常搞混或忘记相似方法，实战根本不知道怎么用。进一步讲，当嵌套了多组括号和回调，且由于不同方法的入参和返回值不同，经常代码检查报错摸不着头脑。</p><p>如果你有这些感觉，那么看完本文对你一定会有收获。本文不会直接告诉你那么多API具体如何使用，而是教会你如何高效区分和掌握不同API的用法。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>JDK8中新增了CompletableFuture类作为异步任务编排的解决方案，它可以被认为是Future的扩展，采用了函数式编程思想简化了任务编排和回调地狱，本文的CompletableFuture会以JDK8为准。</p><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>如何做到快速掌握用法？其实很简单，就是被忽略的函数式接口。很多文章认为直接把方法翻译为具体功能更简单易懂，其实不然，其听我慢慢道来。</p><p>我们先来看看<code>thenCombine</code>方法的声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class="title function_">thenCombine</span></span><br><span class="line">        <span class="params">(CompletionStage&lt;? extends U&gt; other,</span></span><br><span class="line"><span class="params">         BiFunction&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> U,? extends V&gt; fn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> doThenCombine(other.toCompletableFuture(), fn, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这？这一坨都是啥？不急，你不需要理解任何东西，混个眼熟就行，根据功能的不同，CompletableFuture中API的函数式接口入参只有以下六种：</p><table><thead><tr><th>函数式接口</th><th>入参</th><th>返回值</th><th>解释</th></tr></thead><tbody><tr><td>Runnable</td><td>-</td><td>-</td><td>可运行函数：无入参，无结果</td></tr><tr><td>Supplier<T></td><td>-</td><td>T</td><td>提供者函数：仅返回结果</td></tr><tr><td>Consumer<T></td><td>T</td><td>-</td><td>消费者函数：仅消费参数</td></tr><tr><td>Function&lt;T, R&gt;</td><td>T</td><td>R</td><td>一元函数：输入参数，产生结果</td></tr><tr><td>BiFunction&lt;T, U, R&gt;</td><td>T, U</td><td>R</td><td>二元函数：输入两个参数，产生结果</td></tr><tr><td>BiConsumer&lt;T, U&gt;</td><td>T, U</td><td>-</td><td>二元消费者：输入两个参数，无结果</td></tr></tbody></table><p>函数式接口是JDK8新增的一个有且仅有一个抽象方法的接口，用于规定函数式方法，可适用于lambda表达式的书写。当然在本文你可以简单理解为用于规定任务的函数特点（参数和返回值）。</p><p>那么请猜一下下面这个函数式接口的含义是什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">CompletionStage</span>&lt;U&gt;&gt;</span><br></pre></td></tr></table></figure><p>根据上表，它表示一个一元函数，入参为T以及其子类，返回值为<code>CompletionStage&lt;U&gt;</code>类型及其子类。</p><p><strong><code>CompletionStage&lt;U&gt;</code>是何方神圣？它即是CompletableFuture除了Future以外实现的另一个接口，它被描述为异步任务的阶段，定义的任务的阶段操作都会返回一个<code>CompletionStage</code>类型，可链式调用编排任务。</strong></p><p>那么回到刚刚的<code>thenCombine</code>方法，看看它的入参和返回值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thenCombine入参</span></span><br><span class="line">(CompletionStage&lt;? <span class="keyword">extends</span> <span class="title class_">U</span>&gt; other, BiFunction&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> U,? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; fn)</span><br><span class="line"><span class="comment">// thenCombine返回值</span></span><br><span class="line">CompletableFuture&lt;V&gt;</span><br></pre></td></tr></table></figure><p>接受一个<code>CompletionStage</code>和一个<code>BiFunction</code>（二元函数），返回一个<code>CompletionStage</code></p><p>注意以下几部分：</p><ul><li>返回值的泛型<code>&lt;V&gt;</code>，它是参数二BiFunction&lt;? super T,? super U,<code>? extends V</code>&gt;二元函数定义的返回值泛型。</li><li>参数一的泛型<code>&lt;U&gt;</code>，它是参数二BiFunction&lt;? super T,<code>? super U</code>,? extends V&gt;二元函数定义的第二个入参泛型。</li><li>那么二元函数剩下的那个<code>&lt;T&gt;</code>代表什么呢？没错！（突然激动）正是调用者CompletableFuture本身的泛型！</li></ul><p><img src="/2024/02/05/1-CompletableFuture/PixPin_2024-02-06_10-47-14.png" alt="PixPin_2024-02-06_10-47-14"></p><p>最后再看看这个函数的名称thenCombine：”然后结合“，那么这个API的功能就显而易见了：调用者本身作为一个任务产生一个结果<code>T</code>，方法参数传入另一个任务产生结果<code>U</code>，通过二元函数<code>BiFunction</code>结合两个结果产生最终的返回值<code>V</code>。</p><p>让我们看看这个方法实际的用法，其中两个任务是同时进行的，后面会讲到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// supplyAsync异步执行第一个任务</span></span><br><span class="line">CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    print(<span class="string">&quot;厨师做饭&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Food</span>(<span class="string">&quot;蛋炒饭&quot;</span>, <span class="number">40</span>);</span><br><span class="line">    <span class="comment">// thenCombine结合另一个supplyAsync异步任务</span></span><br><span class="line">&#125;).thenCombine(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    print(<span class="string">&quot;厨师煲汤&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Food</span>(<span class="string">&quot;鱼汤&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="comment">// 二元函数接收两个任务结果，处理并返回最终结果（使用Lambda表达式简化匿名内部类的书写）</span></span><br><span class="line">&#125;), (rice, soup) -&gt; &#123;</span><br><span class="line">    print(<span class="string">&quot;顾客吃饭：&quot;</span> + rice.getName() + <span class="string">&quot; 顾客喝汤：&quot;</span> + soup.getName());</span><br><span class="line">    <span class="keyword">return</span> rice.getPrice() + soup.getPrice();</span><br><span class="line">&#125;);</span><br><span class="line">print(<span class="string">&quot;餐厅收款：&quot;</span> + future2.join() + <span class="string">&quot;元&quot;</span>);</span><br></pre></td></tr></table></figure><p>如果你还是有点晕，让我们再看下面两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thenCompose</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenCompose</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> doThenCompose(fn, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// thenApply</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApply</span><span class="params">(Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> doThenApply(fn, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个方法的功能都是作为任务的回调函数，通过一元函数<code>Function</code>处理任务结果，产生最终结果，他们有什么区别呢？</p><p>注意看一元函数<code>Function</code>：</p><ul><li><code>thenCompose</code>方法一元函数返回值的泛型为<code>&lt;? extends CompletionStage&lt;U&gt;&gt; </code></li><li><code>thenApply</code>方法一元函数返回值的泛型为<code>&lt;? extends U&gt;</code></li></ul><p>也就是说，thenCompose必须返回另一个CompletionStage任务结果，而thenApply可以返回任意形式的结果。这和它们的名称也是一致的，Compose为组合（任务），Apply为接受。</p><p>还有一个类似功能的回调方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenAccept</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> doThenAccept(action, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么它与前两者的区别也很明显了，thenAccept的入参是<code>Consumer</code>接口，不产生返回值。</p><p>什么是恍然大明白！看到这里你已经完全掌握CompletableFuture了（开个玩笑）</p><p>接下来会带你全方面认识CompletableFuture，如果你能理解上文说所的，那么继续往下看你就可以很轻松地理解区分CompletableFuture的其他方法。</p><h1 id="方法详解"><a href="#方法详解" class="headerlink" title="方法详解"></a>方法详解</h1><p><strong>CompletableFuture的API可以粗略分为：创建任务、获取结果、任务编排、特殊处理，其中任务编排包括任务连接和任务组合两种。</strong></p><h2 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h2><table><thead><tr><th>API</th><th>入参</th><th>返回值</th><th>解释</th></tr></thead><tbody><tr><td>supplyAsync</td><td>Supplier<U></td><td>CompletableFuture<U></td><td>异步任务，有返回值</td></tr><tr><td>runAsync</td><td>Runnable</td><td>CompletableFuture<Void></td><td>异步任务，无返回值</td></tr><tr><td>completedFuture</td><td>U</td><td>CompletableFuture<U></td><td>直接获取一个任务结果</td></tr></tbody></table><ul><li><code>supplyAsync</code>方法和<code>runAsync</code>方法通过实现不同的函数式接口获得一个异步任务，还记得函数式接口那张表吗，<code>Supplier</code>提供一个返回值，而<code>Runnable</code>不提供。</li><li><code>completedFuture</code>方法可以直接传递一个处理完的结果，不需要实现一个函数式接，可以用于将结果封装为任务。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步创建一个有返回值的任务</span></span><br><span class="line">CompletableFuture&lt;Food&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    print(<span class="string">&quot;厨师做饭&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Food</span>(<span class="string">&quot;蛋炒饭&quot;</span>, <span class="number">40</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 异步创建一个没有返回值的任务</span></span><br><span class="line">CompletableFuture&lt;Void&gt; future2 = CompletableFuture.runAsync(() -&gt; System.out.println(<span class="string">&quot;厨师做饭&quot;</span>));                                               </span><br><span class="line"><span class="comment">// 直接创建一个任务</span></span><br><span class="line">CompletableFuture&lt;Object&gt; future3 = CompletableFuture.completedFuture(<span class="keyword">new</span> <span class="title class_">Food</span>(<span class="string">&quot;蛋炒饭&quot;</span>, <span class="number">40</span>));</span><br></pre></td></tr></table></figure><h2 id="获取结果"><a href="#获取结果" class="headerlink" title="获取结果"></a>获取结果</h2><p>CompletableFuture实现了Future接口获取返回值的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line"></span><br><span class="line">V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br></pre></td></tr></table></figure><p>除此之外，你还可以使用join方法，区别是join帮你捕获了异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待任务完成获取返回值，需要手动捕获或抛出异常</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> future1.get();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等待任务完成获取返回值，不需要手动处理异常</span></span><br><span class="line"><span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> future1.join();</span><br></pre></td></tr></table></figure><h2 id="任务编排"><a href="#任务编排" class="headerlink" title="任务编排"></a>任务编排</h2><p>任务编排的API都有三种形式，分别为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xxx(args...);</span><br><span class="line">xxxAsync(args...);</span><br><span class="line">xxxAsync(args..., Executor executor);</span><br></pre></td></tr></table></figure><ul><li>其中不带<code>Async</code>的为原始方法，默认使用CompletableFuture自带的线程池<code>ForkJoinPool</code>。</li><li>带有<code>Async</code>的被看作是另一个任务阶段，带有<code>Executor</code>的方法可以传入自定义的线程池用于执行任务，带有<code>Executor</code>的方法使用<code>ForkJoinPool</code>。</li></ul><p>这些方法返回值都是CompletionStage类型，具体泛型根据参数中的函数式接口返回值判断，若是Runnable则为<code>&lt;Void&gt;</code>，否则为函数式接口返回值泛型，例如<code>&lt;U&gt;</code>或<code>&lt;V&gt;</code>。</p><p>以刚刚的thenApply为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xxx(args...);</span></span><br><span class="line">CompletionStage&lt;U&gt; <span class="title function_">thenApply</span><span class="params">(Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn)</span>;</span><br><span class="line"><span class="comment">// xxxAsync(args...);</span></span><br><span class="line">CompletionStage&lt;U&gt; <span class="title function_">thenApplyAsync</span><span class="params">(Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn)</span>;</span><br><span class="line"><span class="comment">// xxxAsync(args..., Executor executor);</span></span><br><span class="line">CompletionStage&lt;U&gt; <span class="title function_">thenApplyAsync</span><span class="params">(Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn, Executor executor)</span>;</span><br></pre></td></tr></table></figure><p><strong>之前创建任务的两个方法supplyAsync和runAsync都有对应的Executor重载方法，但没有非Async方法。后面的方法都以不带Async的为例。</strong></p><h3 id="任务连接"><a href="#任务连接" class="headerlink" title="任务连接"></a>任务连接</h3><table><thead><tr><th>API</th><th>入参</th></tr></thead><tbody><tr><td>thenCompose</td><td><code>Function</code>&lt;? super T, ? extends CompletionStage<U>&gt;</td></tr><tr><td>thenAccept</td><td><code>Consumer</code>&lt;? super T&gt;</td></tr><tr><td>thenApply</td><td><code>Function</code>&lt;? super T,? extends U&gt;</td></tr><tr><td>thenRun</td><td><code>Runnable</code></td></tr></tbody></table><p>以上4种方法都是等待任务结束后执行的回调方法，它们的用法区别为：任务之间的交互性质不同（参数和返回值），选用不同的函数式接口实现。</p><p>例如下面的代码，顾客需要接收前面厨师返回的蛋炒饭，吃完返回金钱，因此选用<code>thenCompose</code>这一使用<code>Function</code>函数式接口的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thenCompose连接两个任务</span></span><br><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    print(<span class="string">&quot;厨师做饭&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Food</span>(<span class="string">&quot;蛋炒饭&quot;</span>, <span class="number">40</span>);</span><br><span class="line">&#125;).thenCompose(food -&gt; CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        print(<span class="string">&quot;顾客吃饭：&quot;</span> + food.getName());</span><br><span class="line">    <span class="comment">// TODO 扣减金钱操作</span></span><br><span class="line">        <span class="keyword">return</span> food.getPrice();</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>你也许会好奇，<code>thenApply</code>方法不也是<code>Function</code>吗，该怎么选，偷偷告诉你在前面理解函数式接口一节中已经讲述了这几个方法之间的区别了，如果你已经忘了，那……建议反复阅读第二节。<br>其实使用<code>thenApply</code>也是可以的，只不过<code>thenCompose</code>需要明确返回另一个CompletionStage任务对象。</p><h3 id="任务组合"><a href="#任务组合" class="headerlink" title="任务组合"></a>任务组合</h3><table><thead><tr><th align="left">API</th><th>入参1</th><th>入参2</th><th>解释</th></tr></thead><tbody><tr><td align="left">runAfterBoth</td><td>CompletionStage&lt;?&gt;</td><td><code>Runnable</code></td><td>两个任务都完成后执行可运行函数</td></tr><tr><td align="left">thenCombine</td><td>CompletionStage&lt;? extends U&gt;</td><td><code>BiFunction</code>&lt;? super T,? super U,? extends V&gt;</td><td>两个任务都完成后返回值传递给二元函数</td></tr><tr><td align="left">applyToEither</td><td>CompletionStage&lt;? extends T&gt;</td><td><code>Function</code>&lt;? super T, U&gt;</td><td>任意任务完成后返回值传递给一元函数</td></tr><tr><td align="left">acceptEither</td><td>CompletionStage&lt;? extends T&gt;</td><td><code>Consumer</code>&lt;? super T&gt;</td><td>任意任务完成后返回值传递给消费者</td></tr></tbody></table><p>注意几点：</p><ul><li>这四种方法都是用来组合两个CompletionStage任务的，第一个任务即调用者，第二个任务作为参数传入。</li><li>前两种方法需要实现不关心参数的<code>Runnable</code>，一个是需要实现带有两个参数的<code>BiFunction</code>，对应功能为等待两个任务都完成。</li><li>后两种方法传入的任务泛型为<code>&lt;T&gt;</code>，即CompletableFuture调用者本身泛型，也就是说两个任务的返回类型要保持一致，这与其功能是一致的，即任意任务结束后返回值传递给后面定义的函数处理。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用applyToEither组合两个任务。</span></span><br><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    print(<span class="string">&quot;一号公交车正在赶来&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;).applyToEither(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    print(<span class="string">&quot;二号公交车正在赶来&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 开启了第三个任务用于实现一元函数</span></span><br><span class="line">&#125;), number -&gt; CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    print(<span class="string">&quot;上了&quot;</span> + number + <span class="string">&quot;号公交&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">&#125;).join());</span><br></pre></td></tr></table></figure><p>如果一元函数使用代码块，不开启第三个任务，则上公交车的任务与先赶来的公交车的任务处于同一阶段，不会开启新线程。如果此时改用<code>applyToEitherAsync</code>则会直接开启第三任务线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    print(<span class="string">&quot;一号公交车正在赶来&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;).applyToEither(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    print(<span class="string">&quot;二号公交车正在赶来&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 上了哪辆车，就属于哪个任务</span></span><br><span class="line">&#125;), number -&gt; &#123;</span><br><span class="line">    print(<span class="string">&quot;上了&quot;</span> + number + <span class="string">&quot;号公交&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>任务组合还有两个常用的方法：</p><table><thead><tr><th>API</th><th>入参</th><th>解释</th></tr></thead><tbody><tr><td>allOf</td><td>CompletableFuture&lt;?&gt;… cfs</td><td>所有任务完成后产生结果</td></tr><tr><td>anyOf</td><td>CompletableFuture&lt;?&gt;… cfs</td><td>任意任务结束后产生结果</td></tr></tbody></table><p>这两个方法可以解决多个任务相互组合的情景，以上面公交车为例，有三个公交车的情况可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; bus1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    print(<span class="string">&quot;一号公交车正在赶来&quot;</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;, executor);</span><br><span class="line">CompletableFuture&lt;Integer&gt; bus2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    print(<span class="string">&quot;二号公交车正在赶来&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;, executor);</span><br><span class="line">CompletableFuture&lt;Integer&gt; bus3 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    print(<span class="string">&quot;三号公交车正在赶来&quot;</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;, executor);</span><br><span class="line">CompletableFuture.anyOf(bus1, bus2, bus3).thenApply(number -&gt; &#123;</span><br><span class="line">    print(<span class="string">&quot;上了&quot;</span> + number + <span class="string">&quot;号公交&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>或者简写成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.anyOf(</span><br><span class="line">    CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        print(<span class="string">&quot;一号公交车正在赶来&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;, executor),</span><br><span class="line">    CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        print(<span class="string">&quot;二号公交车正在赶来&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;, executor),</span><br><span class="line">    CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        print(<span class="string">&quot;三号公交车正在赶来&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;, executor)</span><br><span class="line">).thenApply(number -&gt; &#123;</span><br><span class="line">    print(<span class="string">&quot;上了&quot;</span> + number + <span class="string">&quot;号公交&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面介绍的10种任务编排方法，每种方法有3种形式，一共会产生30种方法，根据函数式接口和函数名能够迅速区分开它们的用法。</p><h2 id="特殊处理"><a href="#特殊处理" class="headerlink" title="特殊处理"></a>特殊处理</h2><p>如果任务里出现了异常该如何通知其他任务，如何进行处理呢？CompletableFuture提供了集中特殊处理的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletionStage&lt;T&gt; <span class="title function_">whenComplete</span><span class="params">(BiConsumer&lt;? <span class="built_in">super</span> T, ? <span class="built_in">super</span> Throwable&gt; action)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletionStage&lt;U&gt; <span class="title function_">handle</span><span class="params">(BiFunction&lt;? <span class="built_in">super</span> T, Throwable, ? extends U&gt; fn)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CompletionStage&lt;T&gt; <span class="title function_">exceptionally</span><span class="params">(Function&lt;Throwable, ? extends T&gt; fn)</span>;</span><br></pre></td></tr></table></figure><p>这几个方法可以实现回调函数处理异常，其中<code>whenComplete</code>和<code>handle</code>同样有对应的xxxAsync形式。前面任务若抛出异常则交给Throwable参数，若无异常则为null。</p><p>相信你已经可以通过函数式接口很轻松的区分它们的用法了。</p><p>除此之外，CompletableFuture还提供了其他一些操作例如取消和超时操作等，不再演示。</p><h1 id="原理详解"><a href="#原理详解" class="headerlink" title="原理详解"></a>原理详解</h1><h2 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h2><p>CompletableFuture默认提供的线程池为ForkJoinPool，他的核心线程数为处理器数量减一，例如8核16线程的电脑对应的最大线程数为15。</p><p>为了达到业务线程隔离的目的，通常推荐使用自定义Executor的异步方法，也就是xxxAsync带有Executor参数的方法，且子任务和父任务应该使用不同的线程池，防止线程池循环引用导致死锁。</p><h2 id="Async方法理解"><a href="#Async方法理解" class="headerlink" title="Async方法理解"></a>Async方法理解</h2><p>刚刚等待两辆公交车的例子中使用了applyToEither，哪辆公交车先到达，乘客的函数任务线程就会沿用公交车对应的线程，这很好理解，但如果是厨师的例子呢，顾客函数等待做饭和煲汤两个任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    print(<span class="string">&quot;厨师做饭&quot;</span>);</span><br><span class="line">    sleep(<span class="number">200</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Food</span>(<span class="string">&quot;蛋炒饭&quot;</span>, <span class="number">40</span>);</span><br><span class="line">&#125;, EXECUTOR).thenCombine(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    print(<span class="string">&quot;厨师煲汤&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Food</span>(<span class="string">&quot;鱼汤&quot;</span>, <span class="number">20</span>);</span><br><span class="line">&#125;, EXECUTOR), (rice, soup) -&gt; &#123;</span><br><span class="line">    print(<span class="string">&quot;顾客吃饭：&quot;</span> + rice.getName() + <span class="string">&quot; 顾客喝汤：&quot;</span> + soup.getName());</span><br><span class="line">    <span class="keyword">return</span> rice.getPrice() + soup.getPrice();</span><br><span class="line">&#125;);</span><br><span class="line">print(<span class="string">&quot;餐厅收款：&quot;</span> + future2.join() + <span class="string">&quot;元&quot;</span>);</span><br></pre></td></tr></table></figure><p>这里我让做饭随眠200毫秒，煲汤随眠1000毫秒，打印出结果（睡眠和打印都是自定义的方法）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1 -&gt; 厨师做饭</span><br><span class="line">pool-1-thread-2 -&gt; 厨师煲汤</span><br><span class="line">pool-1-thread-2 -&gt; 顾客吃饭：蛋炒饭 顾客喝汤：鱼汤</span><br><span class="line">main -&gt; 餐厅收款：60元</span><br></pre></td></tr></table></figure><p>结果顾客线程与睡眠时间较长的任务使用了同一个线程吗，我们把睡眠时间交换一下同样成立：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1 -&gt; 厨师做饭</span><br><span class="line">pool-1-thread-2 -&gt; 厨师煲汤</span><br><span class="line">pool-1-thread-1 -&gt; 顾客吃饭：蛋炒饭 顾客喝汤：鱼汤</span><br><span class="line">main -&gt; 餐厅收款：60元</span><br></pre></td></tr></table></figure><p>如果我们把<code>thenCombine</code>换成<code>thenCombineAsync</code>，且使用自定义线程池EXECUTOR，可以看到函数任务在第三个线程执行了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1 -&gt; 厨师做饭</span><br><span class="line">pool-1-thread-2 -&gt; 厨师煲汤</span><br><span class="line">pool-1-thread-3 -&gt; 顾客吃饭：蛋炒饭 顾客喝汤：鱼汤</span><br><span class="line">main -&gt; 餐厅收款：60元</span><br></pre></td></tr></table></figure><p><img src="/2024/02/05/1-CompletableFuture/CompletableFuture.svg" alt="CompletableFuture"></p><p>通过这两个简单的例子我们很容易猜到非Async方法的任务线程会保持与唤醒这个它的任务线程处于同一个CompletionStage任务阶段，那么他底层是如何实现的呢？</p><h2 id="Completion"><a href="#Completion" class="headerlink" title="Completion"></a>Completion</h2><p>实际上，CompletableFuture维护一个<code>CompletionNode</code>链栈，每个栈结点中有一个<code>Completion</code>类型的抽象父类，用于注册不同的阶段操作，可以理解为“观察者”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> CompletionNode completions; <span class="comment">// list (Treiber stack) of completions</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">CompletionNode</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Completion completion;</span><br><span class="line">    <span class="keyword">volatile</span> CompletionNode next;</span><br><span class="line">    CompletionNode(Completion completion) &#123; <span class="built_in">this</span>.completion = completion; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;serial&quot;)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Completion</span> <span class="keyword">extends</span> <span class="title class_">AtomicInteger</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CompletableFuture内部有众多Completion类型的内部类实现，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ThenApply</span>&lt;T,U&gt; <span class="keyword">extends</span> <span class="title class_">Completion</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> CompletableFuture&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; src;</span><br><span class="line">    <span class="keyword">final</span> Function&lt;? <span class="built_in">super</span> T,? <span class="keyword">extends</span> <span class="title class_">U</span>&gt; fn;</span><br><span class="line">    <span class="keyword">final</span> CompletableFuture&lt;U&gt; dst;</span><br><span class="line">    <span class="keyword">final</span> Executor executor;</span><br><span class="line"><span class="comment">// 省略内部方法......</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ThenCombine</span>&lt;T,U,V&gt; <span class="keyword">extends</span> <span class="title class_">Completion</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> CompletableFuture&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; src;</span><br><span class="line">    <span class="keyword">final</span> CompletableFuture&lt;? <span class="keyword">extends</span> <span class="title class_">U</span>&gt; snd;</span><br><span class="line">    <span class="keyword">final</span> BiFunction&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> U,? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; fn;</span><br><span class="line">    <span class="keyword">final</span> CompletableFuture&lt;V&gt; dst;</span><br><span class="line">    <span class="keyword">final</span> Executor executor;</span><br><span class="line"><span class="comment">// 省略内部方法......</span></span><br></pre></td></tr></table></figure><p>这里以依旧以<code>thenCombine</code>厨师为例，我们跟进源码看看：</p><p><img src="/2024/02/05/1-CompletableFuture/PixPin_2024-02-06_11-34-29.png" alt="PixPin_2024-02-06_11-34-29"></p><p>继续进入<code>doThenCombine</code>方法：</p><p><img src="/2024/02/05/1-CompletableFuture/PixPin_2024-02-06_11-36-14.png" alt="PixPin_2024-02-06_11-36-14"></p><ul><li>1631：程序判断了两个任务的result是否都有值，不满足条件进入if语句内（提前设置任务随眠）。</li><li>1632：这里创建了一个<code>ThenCombine</code>类并把自身任务、另一个任务、二元函数fn等信息存入，这个ThenCombine就是上面提到的<code>Completion</code>的一个具体类型。</li><li>1633：创建了一个<code>CompletionNode</code>结点保存<code>ThenCombine</code>，即入栈。</li></ul><p>继续往后走，程序依赖于<code>Unsafe</code>类，对两个任务的返回值、异常进行了一系列的<code>CAS</code>判断，<strong>如果在这期间两个任务都执行完毕，且均未抛出异常</strong>，程序则会执行二元函数BiFunction的apply方法，也就是lambda表达式内的方法，并把两个任务的结果传递进去：</p><p><img src="/2024/02/05/1-CompletableFuture/PixPin_2024-02-06_11-56-02.png" alt="PixPin_2024-02-06_11-56-02"></p><p>如果把随眠时间调整长一些重新，程序注册完<code>Completion</code>后很快就退出了方法<code>thenCombine</code>。</p><p>然后在supplyAsync任务中打上断点，可以看见执行execAsync方法前创建了一个任务<code>AsyncSupply</code>对象，它是实际上需要执行的任务：</p><p><img src="/2024/02/05/1-CompletableFuture/PixPin_2024-02-06_12-03-20.png" alt="PixPin_2024-02-06_12-03-20"></p><p>继承实现关系为：<code>AsyncSupply</code> –继承–&gt; <code>Async</code> –实现–&gt; <code>Runnable</code></p><p>execAsync方内即执行了AsyncSupply任务：</p><p><img src="/2024/02/05/1-CompletableFuture/PixPin_2024-02-06_12-18-41.png" alt="PixPin_2024-02-06_12-18-41"></p><p>那么AsyncSupply做了什么？它执行了函数式接口<code>Supplier</code>的具体实现方法<code>fn</code>，获取了返回值<code>u</code>后传递给了<code>internalComplete</code>方法：</p><p><img src="/2024/02/05/1-CompletableFuture/PixPin_2024-02-06_12-21-59.png" alt="PixPin_2024-02-06_12-21-59"></p><p>这里同样用到了Unsafe类，继续进入<code>postComplete</code>方法：</p><p><img src="/2024/02/05/1-CompletableFuture/PixPin_2024-02-06_12-28-29.png" alt="PixPin_2024-02-06_12-28-29"></p><p><strong>注意为了保证执行到此处的任务是最后一个任务，取消任务二的随眠时间，或者跳过第一个任务的断点</strong></p><p>这里程序进行了循环弹栈操作，两个任务结果都能够通过<code>Completion</code>获取。</p><p><img src="/2024/02/05/1-CompletableFuture/PixPin_2024-02-06_12-46-47.png" alt="PixPin_2024-02-06_12-46-47"></p><p>上面运行的run方法即<code>ThenCombine</code>的run方法，我们进入run方法看看：</p><p><img src="/2024/02/05/1-CompletableFuture/PixPin_2024-02-06_13-02-14.png" alt="PixPin_2024-02-06_13-02-14"></p><p>还记得刚刚注册Completion的代码吗，由于我们选用了非Async方法，传入的Executor为null，<strong>于是直接在当前线程调用了二元函数fn的apply方法</strong>（随眠时间较长的任务一），这就解释了为什么非Async方法执行的函数式接口方法与上一阶段的任务处于同一个线程了，实际上CompletableFuture把它们当作任务的同一阶段了。</p><p>请注意下面三种情况，加深理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况一=================================================</span></span><br><span class="line">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 任务一</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;).thenCombine(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 任务二</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;), (f1, f2) -&gt; &#123;</span><br><span class="line">    <span class="comment">// 代码块与后结束的任务处于同一线程</span></span><br><span class="line">    <span class="keyword">return</span> f1 * f2;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 情况二=================================================</span></span><br><span class="line">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 任务一</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;).thenCombine(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 任务二</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;), (f1, f2) -&gt; CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 开启了第三个supplyAsync异步任务，处于新线程</span></span><br><span class="line">    <span class="keyword">return</span> f1 * f2;</span><br><span class="line">&#125;));</span><br><span class="line"><span class="comment">// 情况三=================================================</span></span><br><span class="line">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 任务一</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;).thenCombine(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 任务二</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;), (f1, f2) -&gt; &#123;</span><br><span class="line">    <span class="comment">// 外层代码块与后结束的任务处于同一线程</span></span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 开启了第三个supplyAsync异步任务，处于新线程</span></span><br><span class="line">        <span class="keyword">return</span> f1 * f2;</span><br><span class="line">    &#125;).join();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>CompletableFuture的任务在不同阶段的操作依赖于CompletionStage阶段。</p><p>而任务编排方法中，相互关联的任务被互相注册为对应类型的Completion并压入CompletionNode栈，在完成任务后根据Completion判断任务是否需要进入下一阶段，弹栈通知注册任务执行相应的方法，也可能是执行后续阶段的方法。</p><p>这个过程中CompletableFuture依赖于Unsafe类的CAS操作，大部分操作实现类无锁并发。</p><p>当然上述流程省略了大量细节，CompletableFuture的运行机制远比这些复杂的多，欢迎纠错和补充。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> CompletableFuture </tag>
            
            <tag> JUC </tag>
            
            <tag> 函数式接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown测试</title>
      <link href="/2024/02/03/0-Markdown/"/>
      <url>/2024/02/03/0-Markdown/</url>
      
        <content type="html"><![CDATA[<h1 id="Java代码块"><a href="#Java代码块" class="headerlink" title="Java代码块"></a>Java代码块</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Block comment */</span></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> AnInterface.CONSTANT;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.Date.parse;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> SomeClass.staticField;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Doc comment here for &lt;code&gt;SomeClass&lt;/code&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> T type parameter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Math#sin(double)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Annotation</span> (name=value)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeClass</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Runnable</span>&gt; &#123; <span class="comment">// some comment</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">T</span> <span class="variable">field</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">double</span> <span class="variable">unusedField</span> <span class="operator">=</span> <span class="number">12345.67890</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">UnknownType</span> <span class="variable">anotherString</span> <span class="operator">=</span> <span class="string">&quot;Another\nStrin\g&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">staticField</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">instanceFinalField</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">protectedField</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> <span class="variable">packagePrivateField</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 语义高亮显示:</span></span><br><span class="line"><span class="comment">   * 生成的光谱为局部变量和形参选择颜色:</span></span><br><span class="line"><span class="comment">   *  Color#1 SC1.1 SC1.2 SC1.3 SC1.4 Color#2 SC2.1 SC2.2 SC2.3 SC2.4 Color#3</span></span><br><span class="line"><span class="comment">   *  Color#3 SC3.1 SC3.2 SC3.3 SC3.4 Color#4 SC4.1 SC4.2 SC4.3 SC4.4 Color#5</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> param1</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> param2</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> param3</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SomeClass</span><span class="params">(AnInterface param1,</span></span><br><span class="line"><span class="params">                  <span class="type">int</span> param2,</span></span><br><span class="line"><span class="params">                  <span class="type">int</span> param3)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">reassignedValue</span> <span class="operator">=</span> <span class="built_in">this</span>.staticField + param2 + param3;</span><br><span class="line">    <span class="type">long</span> localVar1, localVar2, localVar3, localVar4;</span><br><span class="line">    <span class="type">int</span> <span class="variable">localVar</span> <span class="operator">=</span> <span class="string">&quot;IntelliJ&quot;</span>; <span class="comment">// Error, incompatible types</span></span><br><span class="line">    System.out.println(anotherString + toString() + localVar);</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> protectedField + packagePrivateField + staticField;</span><br><span class="line">    <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> parse(<span class="string">&quot;1.2.3&quot;</span>); <span class="comment">// Method is deprecated</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>().countStackFrames(); <span class="comment">// Method is deprecated and marked for removal</span></span><br><span class="line">    reassignedValue ++; </span><br><span class="line">    field.run(); </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">SomeClass</span>() &#123;</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> localVar;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span>[] l = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;().toArray(<span class="keyword">new</span> <span class="title class_">int</span>[CONSTANT]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">AnEnum</span> &#123; CONST1, CONST2 &#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AnInterface</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">CONSTANT</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SomeAbstractClass</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="type">int</span> <span class="variable">instanceField</span> <span class="operator">=</span> staticField;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a>Headers</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># H1</span></span><br><span class="line"><span class="section">## H2</span></span><br><span class="line"><span class="section">### H3</span></span><br><span class="line"><span class="section">#### H4</span></span><br><span class="line"><span class="section">##### H5</span></span><br><span class="line"><span class="section">###### H6</span></span><br><span class="line"></span><br><span class="line">Alternatively, for H1 and H2, an underline-ish style:</span><br><span class="line"></span><br><span class="line"><span class="section">Alt-H1</span></span><br><span class="line"><span class="section">======</span></span><br><span class="line"></span><br><span class="line"><span class="section">Alt-H2</span></span><br><span class="line"><span class="section">------</span></span><br></pre></td></tr></table></figure><h1 id="H1"><a href="#H1" class="headerlink" title="H1"></a>H1</h1><h2 id="H2"><a href="#H2" class="headerlink" title="H2"></a>H2</h2><h3 id="H3"><a href="#H3" class="headerlink" title="H3"></a>H3</h3><h4 id="H4"><a href="#H4" class="headerlink" title="H4"></a>H4</h4><h5 id="H5"><a href="#H5" class="headerlink" title="H5"></a>H5</h5><h6 id="H6"><a href="#H6" class="headerlink" title="H6"></a>H6</h6><p>Alternatively, for H1 and H2, an underline-ish style:</p><h1 id="Alt-H1"><a href="#Alt-H1" class="headerlink" title="Alt-H1"></a>Alt-H1</h1><p>Alt-H2</p><h1 id="Emphasis"><a href="#Emphasis" class="headerlink" title="Emphasis"></a>Emphasis</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Emphasis, aka italics, with <span class="emphasis">*asterisks*</span> or <span class="emphasis">_underscores_</span>.</span><br><span class="line"></span><br><span class="line">Strong emphasis, aka bold, with <span class="strong">**asterisks**</span> or <span class="strong">__underscores__</span>.</span><br><span class="line"></span><br><span class="line">Combined emphasis with <span class="strong">**asterisks and <span class="emphasis">_underscores_</span>**</span>.</span><br><span class="line"></span><br><span class="line">Strikethrough uses two tildes. ~~Scratch this.~~</span><br></pre></td></tr></table></figure><p>Emphasis, aka italics, with <em>asterisks</em> or <em>underscores</em>.</p><p>Strong emphasis, aka bold, with <strong>asterisks</strong> or <strong>underscores</strong>.</p><p>Combined emphasis with <strong>asterisks and <em>underscores</em></strong>.</p><p>Strikethrough uses two tildes. <del>Scratch this.</del></p><h1 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> First ordered list item</span><br><span class="line"><span class="bullet">2.</span> Another item</span><br><span class="line"><span class="bullet">  *</span> Unordered sub-list.</span><br><span class="line"><span class="bullet">1.</span> Actual numbers don&#x27;t matter, just that it&#x27;s a number</span><br><span class="line"><span class="bullet">  1.</span> Ordered sub-list</span><br><span class="line"><span class="bullet">4.</span> And another item.</span><br><span class="line"></span><br><span class="line">   You can have properly indented paragraphs within list items. Notice the blank line above, and the leading spaces (at least one, but we&#x27;ll use three here to also align the raw Markdown).</span><br><span class="line"></span><br><span class="line">   To have a line break without a paragraph, you will need to use two trailing spaces.  </span><br><span class="line">   Note that this line is separate, but within the same paragraph.  </span><br><span class="line">   (This is contrary to the typical GFM line break behaviour, where trailing spaces are not required.)</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> Unordered list can use asterisks</span><br><span class="line"><span class="bullet">-</span> Or minuses</span><br><span class="line"><span class="bullet">+</span> Or pluses</span><br><span class="line"><span class="bullet">-</span> Paragraph In unordered list</span><br><span class="line"></span><br><span class="line">  For example like this.</span><br><span class="line"></span><br><span class="line">Common Paragraph with some text.</span><br><span class="line">And more text.</span><br></pre></td></tr></table></figure><ol><li>First ordered list item</li><li>Another item</li></ol><ul><li>Unordered sub-list.</li></ul><ol><li><p>Actual numbers don’t matter, just that it’s a number</p></li><li><p>Ordered sub-list</p></li><li><p>And another item.</p><p>You can have properly indented paragraphs within list items. Notice the blank line above, and the leading spaces (at least one, but we’ll use three here to also align the raw Markdown).</p><p>To have a line break without a paragraph, you will need to use two trailing spaces.<br>Note that this line is separate, but within the same paragraph.<br>(This is contrary to the typical GFM line break behaviour, where trailing spaces are not required.)</p></li></ol><ul><li>Unordered list can use asterisks</li></ul><ul><li>Or minuses</li></ul><ul><li>Or pluses</li></ul><ul><li><p>Paragraph In unordered list</p><p>For example like this.</p></li></ul><p>Common Paragraph with some text.<br>And more text.</p><h1 id="Inline-HTML"><a href="#Inline-HTML" class="headerlink" title="Inline HTML"></a>Inline HTML</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span>To reboot your computer, press <span class="language-xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>ctrl<span class="language-xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span>+<span class="language-xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>alt<span class="language-xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span>+<span class="language-xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>del<span class="language-xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span>.<span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>To reboot your computer, press <kbd>ctrl</kbd>+<kbd>alt</kbd>+<kbd>del</kbd>.</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span></span><br><span class="line"><span class="code">    &lt;dt&gt;Definition list&lt;/dt&gt;</span></span><br><span class="line"><span class="code">    &lt;dd&gt;Is something people use sometimes.&lt;/dd&gt;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    &lt;dt&gt;Markdown in HTML&lt;/dt&gt;</span></span><br><span class="line"><span class="code">    &lt;dd&gt;Does *not* work **very** well. Use HTML &lt;em&gt;tags&lt;/em&gt;.&lt;/dd&gt;</span></span><br><span class="line"><span class="code">&lt;/dl&gt;</span></span><br></pre></td></tr></table></figure><dl>    <dt>Definition list</dt>    <dd>Is something people use sometimes.</dd><pre><code>&lt;dt&gt;Markdown in HTML&lt;/dt&gt;&lt;dd&gt;Does *not* work **very** well. Use HTML &lt;em&gt;tags&lt;/em&gt;.&lt;/dd&gt;</code></pre></dl><h1 id="Links"><a href="#Links" class="headerlink" title="Links"></a>Links</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">I&#x27;m an inline-style link</span>](<span class="link">https://www.google.com</span>)</span><br><span class="line"></span><br><span class="line">[<span class="string">I&#x27;m an inline-style link with title</span>](<span class="link">https://www.google.com &quot;Google&#x27;s Homepage&quot;</span>)</span><br><span class="line"></span><br><span class="line">[<span class="string">I&#x27;m a reference-style link</span>][<span class="symbol">Arbitrary case-insensitive reference text</span>]</span><br><span class="line"></span><br><span class="line">[<span class="string">I&#x27;m a relative reference to a repository file</span>](<span class="link">../blob/master/LICENSE</span>)</span><br><span class="line"></span><br><span class="line">[<span class="string">You can use numbers for reference-style link definitions</span>][<span class="symbol">1</span>]</span><br><span class="line"></span><br><span class="line">Or leave it empty and use the [link text itself]</span><br><span class="line"></span><br><span class="line">Some text to show that the reference links can follow later.</span><br><span class="line"></span><br><span class="line">[<span class="symbol">arbitrary case-insensitive reference text</span>]: <span class="link">https://hexo.io</span></span><br><span class="line">[<span class="symbol">1</span>]: <span class="link">https://hexo.io/docs/</span></span><br><span class="line">[<span class="symbol">link text itself</span>]: <span class="link">https://hexo.io/api/</span></span><br></pre></td></tr></table></figure><p><a href="https://www.google.com/">I’m an inline-style link</a></p><p><a href="https://www.google.com/" title="Google&#39;s Homepage">I’m an inline-style link with title</a></p><p><a href="https://hexo.io/">I’m a reference-style link</a></p><p><a href="../blob/master/LICENSE">I’m a relative reference to a repository file</a></p><p><a href="https://hexo.io/docs/">You can use numbers for reference-style link definitions</a></p><p>Or leave it empty and use the <a href="https://hexo.io/api/">link text itself</a></p><p>Some text to show that the reference links can follow later.</p><h1 id="Images"><a href="#Images" class="headerlink" title="Images"></a>Images</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hover to see the title text:</span><br><span class="line"></span><br><span class="line">Inline-style:</span><br><span class="line"></span><br><span class="line">![<span class="string">alt text</span>](<span class="link">https://hexo.io/icon/favicon-196x196.png &quot;Logo Title Text 1&quot;</span>)</span><br><span class="line"></span><br><span class="line">Reference-style:</span><br><span class="line">![<span class="string">alt text</span>][<span class="symbol">logo</span>]</span><br><span class="line"></span><br><span class="line">[<span class="symbol">logo</span>]: <span class="link">https://hexo.io/icon/favicon-196x196.png &quot;Logo Title Text 2&quot;</span></span><br></pre></td></tr></table></figure><p>hover to see the title text:</p><p>Inline-style:</p><p><img src="https://hexo.io/icon/favicon-196x196.png" alt="alt text" title="Logo Title Text 1"></p><p>Reference-style:<br><img src="https://hexo.io/icon/favicon-196x196.png" alt="alt text" title="Logo Title Text 2"></p><h1 id="Code-and-Syntax-Highlighting"><a href="#Code-and-Syntax-Highlighting" class="headerlink" title="Code and Syntax Highlighting"></a>Code and Syntax Highlighting</h1><p>Inline code has back-ticks around it.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;JavaScript syntax highlighting&quot;</span>;</span><br><span class="line"><span class="title function_">alert</span>(s);</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;Python syntax highlighting&quot;</span></span><br><span class="line"><span class="built_in">print</span> s</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">No language indicated, so no syntax highlighting.</span><br><span class="line">But let&#x27;s throw in a &lt;b&gt;tag&lt;/b&gt;.</span><br></pre></td></tr></table></figure><h1 id="Tables"><a href="#Tables" class="headerlink" title="Tables"></a>Tables</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|                |ASCII                          |HTML                         |</span><br><span class="line">|----------------|-------------------------------|-----------------------------|</span><br><span class="line">|Single backticks|<span class="code">`&#x27;Isn&#x27;t this fun?&#x27;`</span>            |&#x27;Isn&#x27;t this fun?&#x27;            |</span><br><span class="line">|Quotes          |<span class="code">`&quot;Isn&#x27;t this fun?&quot;`</span>            |&quot;Isn&#x27;t this fun?&quot;            |</span><br><span class="line">|Dashes          |<span class="code">`-- is en-dash, --- is em-dash`</span>|-- is en-dash, --- is em-dash|</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>ASCII</th><th>HTML</th></tr></thead><tbody><tr><td>Single backticks</td><td><code>&#39;Isn&#39;t this fun?&#39;</code></td><td>‘Isn’t this fun?’</td></tr><tr><td>Quotes</td><td><code>&quot;Isn&#39;t this fun?&quot;</code></td><td>“Isn’t this fun?”</td></tr><tr><td>Dashes</td><td><code>-- is en-dash, --- is em-dash</code></td><td>– is en-dash, — is em-dash</td></tr></tbody></table><p>Colons can be used to align columns.</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| Tables        | Are           | Cool  |</span><br><span class="line">| ------------- |:-------------:| -----:|</span><br><span class="line">| col 3 is      | right-aligned |  |</span><br><span class="line">| col 2 is      | centered      |    |</span><br><span class="line">| zebra stripes | are neat      |   </span><br></pre></td></tr></table></figure><table><thead><tr><th>Tables</th><th align="center">Are</th><th align="right">Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td align="center">right-aligned</td><td align="right"></td></tr><tr><td>col 2 is</td><td align="center">centered</td><td align="right"></td></tr><tr><td>zebra stripes</td><td align="center">are neat</td><td align="right"></td></tr></tbody></table><p>The outer pipes (|) are optional, and you don’t need to make the raw Markdown line up prettily. You can also use inline Markdown.</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Markdown | Less | Pretty</span><br><span class="line">--- | --- | ---</span><br><span class="line"><span class="emphasis">*Still*</span> | <span class="code">`renders`</span> | <span class="strong">**nicely**</span></span><br><span class="line">1 | 2 | 3</span><br></pre></td></tr></table></figure><table><thead><tr><th>Markdown</th><th>Less</th><th>Pretty</th></tr></thead><tbody><tr><td><em>Still</em></td><td><code>renders</code></td><td><strong>nicely</strong></td></tr><tr><td>1</td><td>2</td><td>3</td></tr></tbody></table><blockquote><p>You can find more information about LaTeX mathematical expressions here.</p></blockquote><h1 id="Blockquotes"><a href="#Blockquotes" class="headerlink" title="Blockquotes"></a>Blockquotes</h1><blockquote><p>Blockquotes are very handy in email to emulate reply text.<br>This line is part of the same quote.</p></blockquote><p>Quote break.</p><blockquote><p>This is a very long line that will still be quoted properly when it wraps. Oh boy let’s keep writing to make sure this is long enough to actually wrap for everyone. Oh, you can put Markdown into a blockquote.</p></blockquote><h1 id="Horizontal-Rule"><a href="#Horizontal-Rule" class="headerlink" title="Horizontal Rule"></a>Horizontal Rule</h1><p>Three or more…</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line">Hyphens</span><br><span class="line"></span><br><span class="line"><span class="strong">***</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">Asterisks</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">___</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">Underscores</span></span><br></pre></td></tr></table></figure><hr><p>Hyphens</p><hr><p>Asterisks</p><hr><p>Underscores</p><h1 id="Line-Breaks"><a href="#Line-Breaks" class="headerlink" title="Line Breaks"></a>Line Breaks</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Here&#x27;s a line for us to start with.</span><br><span class="line"></span><br><span class="line">This line is separated from the one above by two newlines, so it will be a <span class="emphasis">*separate paragraph*</span>.</span><br><span class="line"></span><br><span class="line">This line is also a separate paragraph, but...</span><br><span class="line">This line is only separated by a single newline, so it&#x27;s a separate line in the <span class="emphasis">*same paragraph*</span>.</span><br></pre></td></tr></table></figure><p>Here’s a line for us to start with.</p><p>This line is separated from the one above by two newlines, so it will be a <em>separate paragraph</em>.</p><p>This line is also a separate paragraph, but…<br>This line is only separated by a single newline, so it’s a separate line in the <em>same paragraph</em>.</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">This is a regular paragraph.</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span></span><br><span class="line"><span class="code">    &lt;tr&gt;</span></span><br><span class="line"><span class="code">        &lt;td&gt;Foo&lt;/td&gt;</span></span><br><span class="line"><span class="code">    &lt;/tr&gt;</span></span><br><span class="line"><span class="code">&lt;/table&gt;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">This is another regular paragraph.</span><br></pre></td></tr></table></figure><p>This is a regular paragraph.</p><table>    <tr>        <td>Foo</td>    </tr></table><p>This is another regular paragraph.</p><h1 id="Youtube-videos"><a href="#Youtube-videos" class="headerlink" title="Youtube videos"></a>Youtube videos</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.youtube.com/watch?feature=player_embedded&amp;v=ARted4RniaU</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://img.youtube.com/vi/ARted4RniaU/0.jpg&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">alt</span>=<span class="string">&quot;IMAGE ALT TEXT HERE&quot;</span> <span class="attr">width</span>=<span class="string">&quot;240&quot;</span> <span class="attr">height</span>=<span class="string">&quot;180&quot;</span> <span class="attr">border</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">Pure markdown version:</span><br><span class="line"></span><br><span class="line">[<span class="string">![IMAGE ALT TEXT HERE</span>](<span class="link">https://img.youtube.com/vi/ARted4RniaU/0.jpg</span>)](<span class="link">https://www.youtube.com/watch?v=ARted4RniaU</span>)</span><br></pre></td></tr></table></figure><p><a href="https://www.youtube.com/watch?feature=player_embedded&v=ARted4RniaU" target="_blank"><img src="https://img.youtube.com/vi/ARted4RniaU/0.jpg"alt="IMAGE ALT TEXT HERE" width="240" height="180" border="10" /></a></p><p>Pure markdown version:</p><p><a href="https://www.youtube.com/watch?v=ARted4RniaU"><img src="https://img.youtube.com/vi/ARted4RniaU/0.jpg" alt="IMAGE ALT TEXT HERE"></a></p>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
